/**
 * Export Service
 *
 * Exports data to PDF, CSV formats
 */

const PDFDocument = require('pdfkit');
const { Parser } = require('json2csv');
const fs = require('fs');
const path = require('path');
const logger = require('../utils/logger');

const XLSX = require('xlsx');

class ExportService {
  constructor() {
    this.exportsDir = path.join(process.cwd(), 'exports');
  }

  /**
   * Initialize exports directory
   */
  async initialize() {
    try {
      if (!fs.existsSync(this.exportsDir)) {
        fs.mkdirSync(this.exportsDir, { recursive: true });
      }
      logger.info('[ExportService] Initialized', { exportsDir: this.exportsDir });
    } catch (error) {
      logger.error('[ExportService] Failed to initialize:', error);
    }
  }

  /**
   * Export insight to PDF
   */
  async exportInsightToPDF(insight) {
    return new Promise((resolve, reject) => {
      try {
        const timestamp = Date.now();
        const filename = `insight-${insight._id}-${timestamp}.pdf`;
        const filepath = path.join(this.exportsDir, filename);

        const doc = new PDFDocument({ margin: 50 });
        const stream = fs.createWriteStream(filepath);

        doc.pipe(stream);

        // Header
        doc.fontSize(24).text(insight.title, { align: 'center' });
        doc.moveDown();

        // Metadata
        doc.fontSize(10).fillColor('#666');
        doc.text(`Category: ${insight.category}`, { continued: true });
        doc.text(`  |  Type: ${insight.type}`, { align: 'left' });
        if (insight.publishedAt) {
          doc.text(`Published: ${new Date(insight.publishedAt).toLocaleDateString()}`);
        }
        doc.moveDown();

        // Divider
        doc.strokeColor('#cccccc').lineWidth(1);
        doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
        doc.moveDown();

        // Excerpt
        if (insight.excerpt) {
          doc.fontSize(12).fillColor('#000').font('Helvetica-Bold');
          doc.text(insight.excerpt, { align: 'justify' });
          doc.moveDown();
        }

        // Content
        doc.fontSize(11).fillColor('#000').font('Helvetica');
        const cleanContent = insight.content.replace(/<[^>]*>/g, ''); // Remove HTML tags
        doc.text(cleanContent, { align: 'justify' });

        // Footer
        doc.moveDown(2);
        doc.fontSize(8).fillColor('#999');
        doc.text('Generated by ElSaif Stock Insights', { align: 'center' });
        doc.text(new Date().toLocaleString(), { align: 'center' });

        doc.end();

        stream.on('finish', () => {
          resolve({ filename, filepath });
        });

        stream.on('error', reject);
      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * Export analytics to CSV
   */
  async exportAnalyticsToCSV(analytics, type = 'daily') {
    try {
      const timestamp = Date.now();
      const filename = `analytics-${type}-${timestamp}.csv`;
      const filepath = path.join(this.exportsDir, filename);

      // Transform data for CSV
      const data = analytics.map(a => ({
        date: a.date.toISOString().split('T')[0],
        totalViews: a.content?.totalViews || 0,
        uniqueViews: a.content?.uniqueViews || 0,
        totalLikes: a.content?.totalLikes || 0,
        totalComments: a.content?.totalComments || 0,
        insightsPublished: a.content?.insightsPublished || 0,
        newUsers: a.users?.newUsers || 0,
        dailyActiveUsers: a.users?.dailyActiveUsers || 0,
        avgResponseTime: a.performance?.avgResponseTime || 0
      }));

      const fields = [
        'date',
        'totalViews',
        'uniqueViews',
        'totalLikes',
        'totalComments',
        'insightsPublished',
        'newUsers',
        'dailyActiveUsers',
        'avgResponseTime'
      ];

      const parser = new Parser({ fields });
      const csv = parser.parse(data);

      fs.writeFileSync(filepath, csv);

      logger.info('[ExportService] Analytics exported to CSV', { filename });

      return { filename, filepath };
    } catch (error) {
      logger.error('[ExportService] Export to CSV failed:', error);
      throw error;
    }
  }

  /**
   * Export user data (GDPR compliance)
   */
  async exportUserData(user, insights, comments, likes, saves) {
    try {
      const timestamp = Date.now();
      const filename = `user-data-${user._id}-${timestamp}.json`;
      const filepath = path.join(this.exportsDir, filename);

      const userData = {
        exportDate: new Date().toISOString(),
        user: {
          id: user._id,
          name: user.name,
          email: user.email,
          role: user.role,
          createdAt: user.createdAt,
          subscription: user.subscription
        },
        insights: insights.map(i => ({
          id: i._id,
          title: i.title,
          excerpt: i.excerpt,
          category: i.category,
          publishedAt: i.publishedAt,
          views: i.analytics?.views || 0
        })),
        comments: comments.map(c => ({
          id: c._id,
          content: c.content,
          insightId: c.insightId,
          createdAt: c.createdAt
        })),
        likes: likes.map(l => ({
          insightId: l.insight,
          likedAt: l.likedAt
        })),
        saves: saves.map(s => ({
          insightId: s.insight,
          note: s.note,
          tags: s.tags,
          savedAt: s.savedAt
        }))
      };

      fs.writeFileSync(filepath, JSON.stringify(userData, null, 2));

      logger.info('[ExportService] User data exported', { userId: user._id, filename });

      return { filename, filepath };
    } catch (error) {
      logger.error('[ExportService] Export user data failed:', error);
      throw error;
    }
  }

  /**
   * Export insights list to CSV
   */
  async exportInsightsToCSV(insights) {
    try {
      const timestamp = Date.now();
      const filename = `insights-${timestamp}.csv`;
      const filepath = path.join(this.exportsDir, filename);

      const data = insights.map(i => ({
        id: i._id.toString(),
        title: i.title,
        category: i.category,
        type: i.type,
        status: i.status,
        views: i.analytics?.views || 0,
        likes: i.analytics?.likes || 0,
        comments: i.analytics?.comments || 0,
        publishedAt: i.publishedAt ? i.publishedAt.toISOString().split('T')[0] : '',
        author: i.author?.name || ''
      }));

      const fields = [
        'id',
        'title',
        'category',
        'type',
        'status',
        'views',
        'likes',
        'comments',
        'publishedAt',
        'author'
      ];

      const parser = new Parser({ fields });
      const csv = parser.parse(data);

      fs.writeFileSync(filepath, csv);

      logger.info('[ExportService] Insights exported to CSV', { filename });

      return { filename, filepath };
    } catch (error) {
      logger.error('[ExportService] Export insights to CSV failed:', error);
      throw error;
    }
  }

  /**
   * Export users list to Excel (XLSX)
   */
  async exportUsersXLSX(users) {
    try {
      const timestamp = Date.now();
      const filename = `users-${timestamp}.xlsx`;
      const filepath = path.join(this.exportsDir, filename);

      // Transform data for Excel
      const data = users.map(user => ({
        ID: user._id.toString(),
        Name: user.name,
        Email: user.email,
        Role: user.role,
        Status: user.isActive ? 'Active' : 'Suspended',
        Nationality: user.nationality || 'N/A',
        JoinedDate: user.createdAt ? new Date(user.createdAt).toLocaleDateString() : 'N/A',
        LastLogin: user.lastLogin ? new Date(user.lastLogin).toLocaleString() : 'Never'
      }));

      // Create workbook and worksheet
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.json_to_sheet(data);

      XLSX.utils.book_append_sheet(wb, ws, 'Users');

      // Write file
      XLSX.writeFile(wb, filepath);

      logger.info('[ExportService] Users exported to Excel', { filename, count: users.length });

      return { filename, filepath };
    } catch (error) {
      logger.error('[ExportService] Export to Excel failed:', error);
      throw error;
    }
  }

  /**
   * Clean up old exports (keep only last 7 days)
   */
  async cleanupOldExports() {
    try {
      const files = fs.readdirSync(this.exportsDir);
      const now = Date.now();
      const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days

      let deletedCount = 0;

      files.forEach(file => {
        const filepath = path.join(this.exportsDir, file);
        const stats = fs.statSync(filepath);
        const age = now - stats.mtimeMs;

        if (age > maxAge) {
          fs.unlinkSync(filepath);
          deletedCount++;
        }
      });

      logger.info('[ExportService] Cleaned up old exports', { deletedCount });

      return deletedCount;
    } catch (error) {
      logger.error('[ExportService] Cleanup failed:', error);
      throw error;
    }
  }
}

module.exports = new ExportService();
